阻塞
    当一个 goroutine 阻塞时，它意味着它正在等待某个事件的发生，例如：
        I/O 操作完成（例如从文件或网络读取）
        通道操作（例如在通道上发送或接收）
        互斥锁获取
        睡眠或计时器过期
    当一个 goroutine 阻塞时，它不再使用任何 CPU 资源，但它仍然占用调度器队列中的一个槽位。

调度
    Go 调度器使用了一种称为 M:N 调度 的技术，其中：
        M：goroutine 的数量（轻量级线程）
        N：操作系统线程（OS 线程）的数量
    调度器将 M 个 goroutine 映射到 N 个 OS 线程上。这允许多个 goroutine 在较少的 OS 线程上并发运行，从而提高系统资源利用率。

调度循环
    调度器的主循环负责：
        选择 一个 goroutine 从运行队列中（一个数据结构，用于存储可运行的 goroutine）
        运行 该 goroutine 在可用的 OS 线程上
        让出 该 goroutine 当它阻塞或完成执行时
        调度 下一个 goroutine 从运行队列中

上下文切换
    当一个 goroutine 阻塞或让出时，调度器执行一个上下文切换，以切换到另一个 goroutine。这涉及到：
        保存 当前 goroutine 的状态（寄存器、栈等）
        恢复 下一个要执行的 goroutine 的状态
        切换 到下一个 goroutine 的 OS 线程（如果必要）

上下文切换机制基于以下技术：
    栈切换：Go 使用分段栈，这允许调度器在不需要复制整个栈的情况下切换 goroutine。
    寄存器保存：调度器使用寄存器窗口技术来保存和恢复 goroutine 的寄存器。
    缓存友好设计：调度器尝试尽量减少缓存失效，通过重用同一个 OS 线程和缓存行来实现。

调度算法
    Go 调度器使用了一组算法来管理 goroutine 的调度，包括：
        工作窃取：当一个 goroutine 阻塞时，调度器尝试从其他 goroutine 中窃取工作，以保持 OS 线程忙碌。
        负载均衡：调度器尝试将 goroutine 均匀分布在可用的 OS 线程上，以最大化 CPU 利用率。
        优先级调度：调度器使用优先级队列来根据 goroutine 的优先级和公平性来调度它们。
    这些算法共同工作，以确保 goroutine 被高效和公平地调度，尽量减少延迟和最大化吞吐量。





