Go语言通过goroutine和调度器（scheduler）实现并发调度。

1. Goroutine： Goroutine是Go语言中轻量级的执行单元，相当于一条独立的执行路径。
    与传统的线程相比，Goroutine的创建和销毁开销非常小，并且可以在单个线程上多路复用。
    通过使用关键字go，我们可以启动一个新的Goroutine，将函数调用包装为一个并发执行的任务。例如：
    func main() {
        go func() {
            // 并发执行的任务
        }()

        // 主Goroutine的任务
    }

2. 调度器（Scheduler）： 调度器是Go语言运行时系统中的一部分，负责调度和管理Goroutine的执行。
    调度器会在适当的时机将Goroutine分配给可用的处理器（Processor），使得Goroutine能够并发执行。
    调度器使用了一种称为"工作窃取"（work-stealing）的算法，它会将新的Goroutine添加到本地队列，并从队列中获取任务来执行。
    如果一个处理器的本地队列为空，它会尝试从其他处理器的队列中窃取任务，以保持工作的均衡分配。

    调度器还负责处理Goroutine的阻塞和唤醒操作。
    当一个Goroutine执行到阻塞操作时（例如等待I/O完成或等待通道接收），调度器会暂停该Goroutine的执行，并将处理器切换到其他可执行的Goroutine上。
    一旦阻塞的操作完成，调度器会唤醒该Goroutine并将其重新放入调度队列。

    调度器的工作是与操作系统的线程密切相关的，它通过创建和管理一组操作系统线程来支持并发执行。
    每个操作系统线程都有一个调度器，可以并发运行多个Goroutine。
    当一个Goroutine发生阻塞或调度器需要进行线程切换时，调度器会在多个操作系统线程之间进行协作。

    通过Goroutine和调度器的配合，Go语言能够实现高效的并发调度。
    开发者只需关注编写并发任务的逻辑，而无需手动管理线程和锁等低级细节。
    这使得编写并发程序变得简单、安全且高效。


3，当一个协程（Goroutine）发生阻塞时，调度器会将该协程暂停，并切换到其他可执行的协程上，以保持并发执行。
    这种切换是通过调度器的协作式调度机制来实现的。

    调度器使用了一种称为"M:N调度"的模型，其中M表示操作系统的线程，N表示Go语言的协程。调度器会创建和管理一组操作系统线程，并将这些线程与协程进行映射和调度。

    具体的调度和切换机制如下：

        协程的阻塞： 当一个协程发生阻塞，例如等待I/O操作完成或等待通道接收时，该协程会将自己标记为阻塞状态，并主动放弃CPU的使用权。

        调度器的工作： 调度器会监视所有协程的状态，并在协程阻塞时进行调度。它会检查当前操作系统线程上运行的协程，如果发现一个协程阻塞，则会将该线程空闲出来。

        协程的切换： 当一个协程阻塞时，调度器会从其他可执行的协程中选择一个来运行。这个选择是基于一种称为"工作窃取"（work-stealing）的算法。调度器会尝试从其他操作系统线程上的协程队列中窃取一个任务，并将其分配给空闲的线程。

        线程的切换： 如果没有其他可执行的协程，或者所有协程都处于阻塞状态，调度器会决定是否创建新的操作系统线程。这取决于调度器的策略和系统的负载情况。
            如果需要创建新的线程，调度器会将一个协程分配给新线程，并将其放入调度队列中。

    基于这种"M:N调度"模型，Go语言的调度器能够在多个协程之间高效地进行切换和调度。
    它避免了传统操作系统线程的高开销，同时还能够利用多核处理器的并发性能。

    需要注意的是，调度器的具体实现可能因不同的Go语言版本而有所差异。
    Go语言的运行时系统是开源的，可以在Go的官方代码库中找到相关的实现细节。调度器的行为和性能也可能受到调度策略、系统负载和硬件环境等因素的影响。