
Golang 的协程切换之所以非常快，是因为 Golang 的协程采用了“用户态线程+多路复用器”的实现方式。

在 Golang 中，每个协程（goroutine）都对应一个轻量级线程（lightweight thread），也称为“用户态线程”（user-level thread）。
这些用户态线程由 Golang 的运行时（runtime）自行管理，而不依赖于操作系统的线程。

Golang 的多路复用器采用了 epoll 和 kqueue 等事件通知机制，使得多个协程可以同时在一个线程内等待多个事件的发生，从而避免了多线程切换时的上下文切换开销。

此外，Golang 还采用了协程的“抢占式调度”（preemptive scheduling）机制，即当一个协程执行时间过长或者发生了阻塞时，
运行时会主动把 CPU 时间分配给其他可运行的协程，从而保证每个协程都能够得到一定的执行时间，避免了某个协程一直占用 CPU 而导致其他协程无法运行的情况。

因此，Golang 的协程切换速度非常快，可以轻松地创建数百万个协程，从而极大地提高了程序的并发性能和可伸缩性。