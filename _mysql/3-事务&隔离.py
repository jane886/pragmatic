"""

1，事务的特性：原子性、一致性、隔离性、持久性
原子性：一个事务中的所有操作要么全部成功，要么全部失败
一致性：事务执行前后，数据的完整性没有被破坏
隔离性：多个事务并发执行的时候，一个事务的执行不会被其他事务干扰
持久性：事务一旦提交，对数据库的改变就是永久性的


2，多个事务执行的时候会发生的问题：脏读、幻读、不可重复读
脏读：一个事务读取到另一个事务未提交的数据
幻读：一个事务读取到另一个事务提交的数据，但是另一个事务又插入了新的数据
不可重复读：一个事务读取到另一个事务提交的数据，但是另一个事务又更新了数据


3，事务的隔离级别有四种
答案：读未提交、读提交、可重复读、串行化
读未提交：一个事务的更改未提交，其他事务能看到更改
读提交：一个事务的更改提交后，其他事务才看到
可重复读：一个事务执行过程中看到的数据始终是一样的。另外为提交的更改对其他事务不可见
串行化：对一个事务的记录会加读写锁，有冲突的时候，下一个事务要等待前一个事务执行完后才可以执行


MVcc：多版本并发控制，是一种乐观锁的实现方式，通过在每行记录后面保存多个版本的数据来实现的。每个事务在读取数据的时候，只读取当前版本的数据，而不是读取最新的数据。这样就可以避免读取到未提交的数据。

MySQL 锁的分类：
1，表锁：锁住整张表，读锁和写锁
2，行锁：锁住一行或者多行，读锁和写锁
3，页锁：锁住一页，读锁和写锁
4，意向锁：锁住表的意向，读锁和写锁

MySQL 锁的类型：
1，共享锁（S锁）：读锁，允许其他事务读取该行，但是不允许其他事务修改该行
2，排他锁（X锁）：写锁，允许其他事务修改该行，但是不允许其他事务读取该行
3，意向共享锁（IS锁）：读锁的意向锁，允许其他事务给该行加读锁，但是不允许其他事务给该行加写锁
4，意向排他锁（IX锁）：写锁的意向锁，允许其他事务给该行加写锁，但是不允许其他事务给该行加读锁

MySQL 锁的粒度：
1，表锁：锁住整张表，读锁和写锁
2，行锁：锁住一行或者多行，读锁和写锁
3，页锁：锁住一页，读锁和写锁
4，意向锁：锁住表的意向，读锁和写锁


间隙锁：当一个事务对某个范围的数据进行加锁操作时，如果这个范围内没有数据，那么这个事务会对这个范围的前后两个数据加锁，这个锁就是间隙锁

MySQL 锁的算法：
1，记录锁：锁住一行或者多行，读锁和写锁
2，间隙锁：锁住一行或者多行，读锁和写锁
3，表锁：锁住整张表，读锁和写锁
4，意向锁：锁住表的意向，读锁和写锁

gap锁：当一个事务对某个范围的数据进行加锁操作时，如果这个范围内没有数据，那么这个事务会对这个范围的前后两个数据加锁，这个锁就是间隙锁

GIL：全局解释器锁，是Python的一个特性，它保证了同一时刻只有一个线程在执行Python字节码，这样就保证了线程安全。
    但是GIL会导致多线程的并发性能不高，因为同一时刻只有一个线程在执行Python字节码，其他线程都在等待GIL的释放。

gil的释放：
1，遇到IO操作的时候，会释放GIL
2，遇到耗时操作的时候，会释放GIL
3，遇到C扩展的时候，会释放GIL

gil的获取：
1，遇到IO操作的时候，会获取GIL
2，遇到耗时操作的时候，会获取GIL
3，遇到C扩展的时候，会获取GIL

gil 可以去掉吗？
1，可以通过C扩展去掉GIL
2，可以通过多进程去掉GIL


垃圾回收机制
1，引用计数：引用计数是Python的一个特性，它用来记录对象的引用次数，当对象的引用次数为0的时候，就会被垃圾回收机制回收
2，标记清除：标记清除是Python的一个特性，它用来标记垃圾对象，然后清除垃圾对象
3，分代回收：分代回收是Python的一个特性，它用来回收老一代的垃圾对象


Redis set 命令
1，set key value：设置指定key的值
2，set key value ex seconds：设置指定key的值，并且设置过期时间
3，set key value px milliseconds：设置指定key的值，并且设置过期时间
4，set key value nx：设置指定key的值，只有当key不存在的时候才设置
5，set key value xx：设置指定key的值，只有当key存在的时候才设置
6，set key value keepttl：设置指定key的值，保留原来的过期时间
7，set key value ex seconds nx：设置指定key的值，并且设置过期时间，只有当key不存在的时候才设置
8，set key value ex seconds xx：设置指定key的值，并且设置过期时间，只有当key存在的时候才设置
9，set key value px milliseconds nx：设置指定key的值，并且设置过期时间，只有当key不存在的时候才设置
10，set key value px milliseconds xx：设置指定key的值，并且设置过期时间，只有当key存在的时候才设置
11，set key value keepttl nx：设置指定key的值，保留原来的过期时间，只有当key不存在的时候才设置
12，set key value keepttl xx：设置指定key的值，保留原来的过期时间，只有当key存在的时候才设置


Python 有哪些数据类型
1，整型：int
2，浮点型：float
3，字符串：str
4，布尔型：bool
5，列表：list
6，元组：tuple
7，字典：dict
8，集合：set


有哪些数据结构
1，数组：array
2，链表：linked list
3，栈：stack
4，队列：queue
5，散列表：hash table
6，二叉树：binary tree
7，堆：heap
8，图：graph


网络结构
1，OSI七层模型
2，TCP/IP四层模型
3，HTTP三层模型

OSI七层模型
1，应用层：应用层是最上层的一层，它是面向用户的，它的作用是为用户提供应用服务，比如HTTP、FTP、DNS、SMTP、POP3、TELNET、SSH、SNMP、NFS、RPC等
2，表示层：表示层是应用层和会话层之间的一层，它的作用是将数据转换为能够被接收方识别的格式，比如将数据转换为二进制格式
3，会话层：会话层是表示层和传输层之间的一层，它的作用是建立、管理和终止会话，比如建立会话、终止会话、同步会话等
4，传输层：传输层是会话层和网络层之间的一层，它的作用是提供端到端的可靠的数据传输服务，比如TCP、UDP等
5，网络层：网络层是传输层和数据链路层之间的一层，它的作用是将数据包从源节点传输到目的节点，比如IP、ICMP、ARP、RARP、OSPF、RIP等
6，数据链路层：数据链路层是网络层和物理层之间的一层，它的作用是将数据包从源节点传输到目的节点，比如以太网、无线局域网、PPP、SLIP等
7，物理层：物理层是最下层的一层，它的作用是定义物理设备如何传输数据，比如网线、光纤、集线器、中继器、网卡、调制解调器等

TCP/IP四层模型
1，应用层：应用层是最上层的一层，它是面向用户的，它的作用是为用户提供应用服务，比如HTTP、FTP、DNS、SMTP、POP3、TELNET、SSH、SNMP、NFS、RPC等
2，传输层：传输层是应用层和网络层之间的一层，它的作用是提供端到端的可靠的数据传输服务，比如TCP、UDP等
3，网络层：网络层是传输层和数据链路层之间的一层，它的作用是将数据包从源节点传输到目的节点，比如IP、ICMP、ARP、RARP、OSPF、RIP等
4，数据链路层：数据链路层是网络层和物理层之间的一层，它的作用是将数据包从源节点传输到目的节点，比如以太网、无线局域网、PPP、SLIP等

HTTP三层模型
1，应用层：应用层是最上层的一层，它是面向用户的，它的作用是为用户提供应用服务，比如HTTP、FTP、DNS、SMTP、POP3、TELNET、SSH、SNMP、NFS、RPC等
2，传输层：传输层是应用层和网络层之间的一层，它的作用是提供端到端的可靠的数据传输服务，比如TCP、UDP等
3，网络层：网络层是传输层和数据链路层之间的一层，它的作用是将数据包从源节点传输到目的节点，比如IP、ICMP、ARP、RARP、OSPF、RIP等

三次握手
1，第一次握手：客户端发送一个SYN包（SYN=j）到服务器，并进入SYN_SEND状态，等待服务器确认
2，第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
3，第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ACK=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

四次挥手
1，第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态
2，第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务器进入CLOSE_WAIT状态
3，第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态
4，第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到序号+1，服务器进入CLOSED状态，完成四次挥手

TCP和UDP的区别
1，TCP是面向连接的，UDP是无连接的
2，TCP提供可靠的服务，UDP尽最大努力交付
3，TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，UDP是面向报文的
4，TCP有拥塞控制，UDP没有
5，TCP首部开销20字节，UDP的首部开销小，只有8个字节
6，TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

TCP的拥塞控制
1，慢开始：慢开始是指当一个新的连接被建立时，TCP的发送方会从一个较小的值开始，慢慢地提高发送的数据量，直到达到拥塞窗口的大小
2，拥塞避免：拥塞避免是指当网络拥塞时，TCP的发送方会减慢发送的速率，以降低网络的拥塞程度
3，快重传：快重传是指当TCP接收方收到三个重复的ACK时，就认为有数据包丢失了，就会立即重传丢失的数据包
4，快恢复：快恢复是指当TCP接收方收到三个重复的ACK时，就认为有数据包丢失了，就会立即重传丢失的数据包，同时将拥塞窗口设置为慢开始阶段的阈值

TCP的流量控制
1，停止等待协议：停止等待协议是指发送方发送数据后，必须等待接收方的确认，如果在规定的时间内没有收到确认，发送方会重发数据，直到收到接收方的确认
2，滑动窗口协议：滑动窗口协议是指发送方发送数据后，不必等待接收方的确认，而是发送一定数量的数据后，再等待接收方的确认，如果在规定的时间内没有收到确认，发送方会重发数据，直到收到接收方的确认

TCP的可靠传输
1，超时重传：超时重传是指当TCP发送方发送数据后，如果在规定的时间内没有收到接收方的确认，发送方会重发数据，直到收到接收方的确认
2，确认重传：确认重传是指当TCP接收方收到数据后，会立即发送一个确认，如果在规定的时间内没有收到发送方的确认，接收方会重发确认，直到收到发送方的确认
3，数据重传：数据重传是指当TCP接收方收到数据后，会立即发送一个确认，如果在规定的时间内没有收到发送方的确认，接收方会重发确认，直到收到发送方的确认

TCP的连接管理
1，三次握手：三次握手是指建立一个TCP连接时，需要客户端和服务器总共发送3个包，这3个包的发送顺序如下
2，四次挥手：四次挥手是指断开一个TCP连接时，需要客户端和服务器总共发送4个包，这4个包的发送顺序如下


TCP的状态转换
1，LISTEN：服务器监听来自客户端的SYN请求
2，SYN_RECV：服务器收到客户端的SYN请求后，向客户端发送SYN+ACK响应
3，ESTABLISHED：客户端收到服务器的SYN+ACK响应后，向服务器发送ACK报文，连接建立
4，FIN_WAIT_1：客户端发送FIN报文，请求关闭连接
5，FIN_WAIT_2：服务器收到FIN报文后，发送ACK报文，客户端收到ACK报文后，进入FIN_WAIT_2状态
6，TIME_WAIT：服务器收到FIN报文后，发送ACK报文，服务器进入CLOSE_WAIT状态，客户端收到ACK报文后，进入TIME_WAIT状态
7，CLOSE_WAIT：服务器收到客户端的FIN报文后，进入CLOSE_WAIT状态
8，LAST_ACK：客户端收到服务器的ACK报文后，发送FIN报文，服务器收到FIN报文后，发送ACK报文，客户端收到ACK报文后，进入CLOSED状态，服务器收到ACK报文后，进入CLOSED状态
9，CLOSED：客户端和服务器都进入CLOSED状态，TCP连接释放





"""