4，JVM的垃圾收集器如何进行内存分配？
    JVM的垃圾收集器在进行内存分配时，通常采用以下策略和技术：

    对象的生命周期：

    JVM通过判断对象的生命周期来确定内存分配的方式。通常将对象分为新生代（Young Generation）和老年代（Old Generation）两个部分。
    新生代用于存储新创建的对象，其中又分为Eden空间和两个Survivor空间。大部分对象在新生代中被创建并很快变为垃圾。只有少数对象会在新生代中存活较长时间。
    老年代用于存储存活时间较长的对象。
    分代回收：

    垃圾收集器基于分代回收的概念，根据对象的年龄将内存分为不同的代。不同的代使用不同的垃圾收集算法和策略。
    新生代使用复制算法（Copying Algorithm）进行垃圾回收。对象在Eden空间分配，当Eden空间满时，进行一次Minor GC（新生代的垃圾回收）。幸存的对象会被复制到Survivor空间，当Survivor空间也满时，再次进行复制和回收操作。经过多次回收后，仍然存活的对象会被晋升到老年代。
    老年代使用标记-清除（Mark and Sweep）或标记-整理（Mark and Compact）算法进行垃圾回收。这些算法会标记活动对象，然后清除或整理未被标记的垃圾对象。
    内存分配器：

    JVM中的内存分配器负责在堆中分配新对象的内存空间。常见的内存分配器包括指针碰撞（Bump the Pointer）和空闲列表（Free List）两种。
    指针碰撞分配器将堆内存一分为二，通过移动指针来分配内存空间。这种分配器要求堆中的对象分配和回收是按照固定顺序进行的。
    空闲列表分配器维护一个空闲列表，记录可用的内存块。它根据需要从空闲列表中找到合适大小的内存块来分配对象。
    线程本地分配缓冲（Thread-Local Allocation Buffers，TLABs）：

    TLABs是一种优化技术，用于提高多线程环境下的内存分配效率。每个线程都有一个私有的TLAB，用于分配新对象的内存空间。
    TLABs减少了线程之间的竞争，提高了分配速度。当TLAB的空间不足时，线程将从共享的内存池（Shared Heap）中分配新的TLAB。
    动态对象年龄判定：

    垃圾收集器使用动态对象年龄判定来决定对象是否晋升到老年代。通过在每次垃圾回收后统计对象的存活次数，可以根据一定的策略将对象晋升到老年代。
    需要注意的是，不同的垃圾收集器和JVM实现可能有不同的内存分配策略和算法。这些策略和算法的选择与具体的应用需求、硬件环境以及性能目标等有关。