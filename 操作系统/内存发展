内存保护
    操作系统的一个主要职责就是隔离应用程序，比如说，web浏览器不应该能够干扰到文本编辑器。
    为了实现此目的，操作系统会利用硬件的某些功能来确保一个进程的内存空间不会被另一个进程访问到。
    当然，不同的硬件和操作系统也会有不同的实现。
    同时在发生进程切换的时候，操作系统也会及时的更新相应区域及其访问权限，这样就确保了每个进程只能访问自己的地址空间，从而达到隔离进程的作用。

    另一方面，在x86平台上，硬件支持两种不同的内存保护方式：分段（segmentation）和分页（paging）。


分段
    分段技术早在1978年就已经出现，起初是为了增加CPU的寻址空间。
    当时的情况是CPU只使用16位地址，这将可寻址空间限制为64KiB（216）。
    为了访问到更高的内存，一些段寄存器被引入进来，每个段寄存器都包含一个偏移地址。
    CPU将这些偏移地址作为基地址，加到应用程序要访问的内存地址上，这样它就可以使用到高达1MiB的内存空间了。

    段寄存器有好几种，CPU会根据不同的内存访问请求而选择不同的段寄存器：
        对于取指令请求，代码段寄存器CS会被使用；
        堆栈操作（push/pop）会用到堆栈段寄存器SS；
        其他操作则使用数据段DS或额外的段ES，后来又添加了两个可以自由使用的段寄存器FS和GS。

    在分段技术的第一版实现中，段寄存器直接存放了段偏移量，并且没有访问控制的检查。
    后来，随着保护模式的引入，这种情况发生了改变。
    当CPU以这种模式运行时，段寄存器中包含了一个局部或全局描述符表中的索引，该表除了包含偏移地址外，还包含段大小和访问权限。
    通过为每个进程加载单独的描述符表，操作系统就能将进程的内存访问限制到它自己的地址空间内，从而达到隔离进程的作用。

    通过在实际访问发生之前修改要访问的目标地址，分段技术实际上已经在使用一种现在广为使用的技术：虚拟内存。


虚拟内存
    虚拟内存背后的思想是将内存地址从底层存储设备中抽象出来。

    即在访问存储设备前，增加一个地址转换的过程。对于分段来说，这里的转换过程就是为内存地址加上一个段偏移量。
    例如，当一个进程在一个偏移量为0x1111000的段中访问内存地址0x1234000时，它实际访问到的地址是0x2345000。

    为了区分这两种地址类型，我们将转换前的地址称为虚拟地址（virtual），转换后的地址称为物理地址（physical）。
    这两种地址之间的一个重要区别是物理地址是唯一的，并且总是指向同一个内存位置。

    而虚拟地址则依赖于转换函数，所以两个不同的虚拟地址完全有可能指向相同的物理地址。
    同样，相同的虚拟地址在不同的转换函数作用下也有可能指向不同的物理地址。


    在这里，相同的程序运行了两次，但是使用了不同的转换函数。
    第一个进程实例的段偏移量为100，因此它的虚拟地址0-150被转换为物理地址100-250。
    第二个进程实例的偏移量为300，所以它的虚拟地址0-150被转换为物理地址300-450。
    这样就允许了两个进程互不干扰地运行相同的代码并且使用相同的虚拟地址。

    这个技术的另一个优点是，不管程序内部使用什么样的虚拟地址，它都可以被加载到任意的物理内存点。
    这样，操作系统就可以在不重新编译程序的前提下，充分利用所有的内存。


内存碎片
    在将内存地址区分为虚拟地址和物理地址之后，分段技术作为连接这两者的桥梁就显得尤为重要。
    但分段技术的一个问题在于它可能导致内存碎片化。比如，如果我们想在上面两个进程的基础上再运行第三个程序：
    可以看到，即便有足够多的空闲内存，我们也无法将第三个进程映射到物理内存中。
    这里的主要问题是，我们需要连续的大块内存，而不是大量不连续的小块内存。

    解决这种碎片化问题的一个办法就是，先暂停程序的执行，移动已使用的内存使他们更紧凑一些，然后更新转换函数，最后再恢复执行：
    但在碎片整理的过程中，需要移动大量的内存，这会降低性能。而且这种整理需要定期完成，以免内存变得过于分散。
    这使得程序会被随机的暂停并且失去响应，所以这种方法会使得程序的性能变得不可预测。

    综上，内存碎片化是使得大多数系统不再使用分段技术的原因之一。
    事实上，64位的x86甚至不再支持分段，而是使用另一种分页技术，因为它可以完全避免这些碎片问题。


分页
    分页技术的核心思想是将虚拟内存空间和物理内存空间划分成固定大小的小块，虚拟内存空间的块称为页(pages)，物理地址空间的块称为帧(frames)。
    每一个页都可以单独映射到一个帧上，这使得我们可以将一个大块的虚拟内存分散的映射到一些不连续的物理帧上。

    如果回顾刚才内存碎片化的示例，我们可以看到使用分页显然更有优势：
    在本例中，我们的页大小为50字节，这意味着我们的每个进程空间都被划分成了三页，每页都单独映射到一个帧，
    因此连续的虚拟内存空间可以被映射到非连续的物理帧上。
    这就允许我们在没有执行碎片整理的情况下直接运行第三个程序。

