1，基于 k8s 这一块云原生，具体讲讲是怎么展开落地的，为什么选型 k8s

2，k8s 是跑在云上面还是自己部署的

3，讲一下正常情况下 k8s 本身怎么做到高可用，比如 master 有几个组件对吧，它怎么做到高可用……或者讲讲 k8s 整体的一个架构

4，再讲一下控制面这些组件分别是怎么做到高可用的，因为我们整体部署集群的时候肯定不是单副本的嘛，那这些组件是怎么做到高可用的

5，刚才讲到 deployment 和 statefulSet 有什么区别吗，使用场景有哪一些

6，这个无状态和有状态怎么定义呢，怎么区分这个

7，在使用 seldon 部署大模型这一块过程中有没有发现什么问题，它有哪些优缺点

8，做服务容器化的过程中，怎么通过docker构建镜像，通过home封装应用这一块，怎么真正发布到线上去，ci 构建完后 cd 怎么部署

9，现在代码是写哪个语言，Python 和 Go 在并发这一块有什么区别

10，Redis 怎么做内存淘汰机制的

11，算法题 LRU
	实现 get 和 put 操作都是 O(1)复杂度
	如果不用 collections 库的 OrderedDict，应该怎么实现

业务：字节公有云火山引擎有两个业务，机器学习平台、大模型平台，这两个平台目前团队在做，规模不方便说

岗位主要涉及到cicd平台、k8s整体维护、模型部署这些，机器学习业务大模型业务相关的东西，偏基础设施、平台开发、infra这一块



一面
1，celery 如何实现延迟消息

使用 ETA 或 Countdown。
参考文献：http://docs.celeryproject.org/en/latest/userguide/calling.html#calling-eta
用法见图示

2，时间的延迟如何做到？是在到了时间后放入 worker 还是一开始就通知 woker，让其自动计时。

时间到了才会执行

3，消息队列的时间控制机制具体如何执行，如果一开始是存在1小时之后执行的任务，然后来了一些需要立马执行的任务，此时是什么样的安排方式？

需要立马执行的任务立马执行，同时延时任务继续计时，这个计时是保证任务不在 1 小时之内执行，而不是精确地在 1 小时后的那个点上执行，如果发生任务堆积，延时任务会在队列中等待。

4，celery 踩到的坑是什么？

当使用 Redis 作为中间件时，visibility timeout 默认为一小时。
如果一个任务没有在 visibility timeout 时间内 ack，就会被重新分发到另一个 worker 去执行。
这意味着如果设置了超过一小时的延时任务，会导致重复执行。
解决方案是把 visibility timeout 设置到最够大，或在任务中做排重校验。

worker 除了会从 broker 获取任务, 还会订阅 其他worker的心跳,
在worker很多的情况下, 会导致 woker  处理真正的任务变少, 导致任务堆积
所以一般启动 worker 的时候都会带上 --without-mingle --without-gossip --without-heartbeat 这些 tag
https://stackoverflow.com/questions/50328971/celery-disable-heartbeat-between-workers

5，flask 的优点是什么？蓝图的实现原理是什么？

1 简洁，Flask 只提供最基本的功能，相对于臃肿的 django，开发者可以更加专注于你要提供的功能。
2 灵活，丰富的第三方库，需要的时候插入。
蓝图的作用是实现模块化，原理是蓝图将其内部注册的路由记录到一个延迟列表中，当 app 调用注册蓝图时，将这个列表中的路由添加到 app 的 url_map 中

6，mysql 的优化，索引是什么样的？

索引是 B+ 树，这是一种多路搜索树。非叶子节点存放键值和指针。叶子节点存放数据。
（见图）https://blog.csdn.net/A_zhangq/article/details/99662693

7，为什么用 B+树 而不用 红黑树？

红黑树是二叉树，B+ 树是多叉树，只需要很少的层数就能实现很大的分支数，减少树的层数可以减少 IO 次数，提高速度。

8，索引是加的越多越好还是越少越好？

取决于实际需求。增加索引可以加快查询速度，但降低插入速度。这是一种 trade off，要根据实际情况权衡。

9，为什么加索引不能加过多？

同上

10，如果有一个表60%的字段都需要索引，会怎么处理。

建议使用专供 OLAP 的数据库。OLTP 专注于线上事务，使用少量必要索引。从 OLTP 批量同步到 OLAP，在 OLAP 上加索引

11，联合索引是什么原理？a b c 是联合索引，那么查找 b c 是否会命中索引？

联合索引就是把多个字段组合在一起形成的索引
只适用于查询以下几种情况：
a
a and b
a and b and c
不适用于：
a or b
b and c 等等

12，对数据库的锁有什么了解吗？间隙锁了解吗？平时用的多吗？

读锁：其他事务可以读，不可以写
写锁：其他事务不可以读，不可以写
间隙锁：在一个索引区间加锁，避免区间内插入数据。防止幻读。

13，事务平时用的多吗？在事务的过程中数据的锁的状态？如何保持数据的一致性。

事务的 ACID 特性：
Atomicity 原子性
Consistency 一致性
Isolation 隔离性
Durability 持久性
事务的四个隔离级别：读未提交，读已提交，可重复读，可串行化。
最高的隔离级别（可串行化）提供最强的一致性，牺牲性能。该隔离级别使用二阶段锁定（2PL）实现，第一阶段只能获得锁，第二阶段只能释放锁。
在可重复读或更低的隔离级别，可以使用显式锁定、原子写、CAS（compare and set）等以保持一致性。

14，redis 了解吗？zset 这个数据类型了解吗？

顾名思义 REmote DIctionary Server，远程字典服务，字典即 Key - Value。
Value 可以是：
string（字符串），
hash（哈希），
list（列表），
set（集合），
zset（sorted set 有序集合）。

15，io多路复用是什么？

io 复用是说多个 tcp 连接复用一个线程，反过来说就是一个线程或一组线程处理多个连接。
有 select poll epoll 三种

16，对协程了解吗？

协程是在单线程下，遇到 io 阻塞时用户程序自己控制切换到另一个任务执行，以使本线程最大限度地处于就绪态。进程线程由操作系统调度，而协程由应用程序调度，切换开销小。

17，kill 掉一个进程的过程是什么样的？

从 PCB 集合中检索出该进程的 PCB，从中读出该进程的状态。若进程处于执行状态，终止该进程的执行，重新调度 CPU。若有子孙进程，将所有子孙进程终止。将进程全部资源归还其父进程或系统。将其 PCB 从所在队列中移除。

18，公司项目是一个什么什么情况？

略

19，四个 int 型数组，给定一个 n，在每个数组里面取一个数，获取所有的满足和为 n 的排列。

class Solution(object):
    def fourSum(self, A, B, C, D, n):
        two_sum = {}
        res = []
        for a in A:
            for b in B:
                k = a + b
                if k not in two_sum:
                    two_sum[k] = [(a, b)]
                else:
                    two_sum[k].append((a, b))

        for c in C:
            for d in D:
                k = n - (c + d)
                if k in two_sum:
                    for i in two_sum[k]:
                        res.append(i + (c, d))
        return res


s = Solution()
r = s.fourSum(
    [1, 2],
    [-2, -1],
    [-1, 2],
    [0, 2],
    n=0)
print(r)

# output: [(2, -1, -1, 0), (1, -2, -1, 2)]

二面
1，mysql 中的常用引擎有哪些？

innodb 和 myisam

2，innodb 和 myisam 之间有什么区别？（不断的问还有什么还有什么）

innodb 支持事务 myisam 不支持事务
innodb 支持行锁、间隙锁等，myisam 只支持表锁
innodb 支持外键，myisam 不支持外键
innodb 一致性强、查询插入慢，myisam 查询插入快

3，innodb 和 myisam 性能上有什么区别，场景什么区别？

myisam 查询插入快，适合以读和插入操作为主，只有少量的更新和删除，且不要求事务特性的场景
innodb 适合有事务要求的场景

4，为什么读用 myisam？

myisam 非聚簇索引，索引指向具体地址；innodb 聚簇索引，索引和数据放在一起。
innodb 要维护额外的 mvcc，成本高。

5，建立了一张 innodb 的学生表，学号为主键，姓名 name 为索引，画出 name B+ 树的结构。
详细画出叶子节点和根节点，存储什么信息，彼此之间的关系是什么？

见图

6，B+ 树和 B 树的区别？

B 树非叶子节点关键字是指针的分界点，即：关键字数 = 指针数 - 1
B+ 树非叶子节点关键字数和指针数相同
B 树搜索可能在非叶子节点命中
B+ 树搜索一定会走到叶子节点，叶子节点有到下一个叶子节点的指针

7，B+树叶子节点的连接怎么连，能不能画一下。

见题目 5 图

8，mysql 的事务隔离级别。每个级别代表什么含义，会有什么问题。

读未提交：防止脏写，不防止脏读。脏写：事务 A 写的数据未提交被 B 写入覆盖
读已提交：防止脏读。脏读：事务 A 写的数据未提交被 B 读取
可重复读：防止不可重复读。不可重复度：事务 A 读取的数据，被事务 B 修改并提交，A 再次读取发现不一致。使用 MVCC 提供一致性快照，实现可重复读。
可串行化：防止幻读。幻读：事务 A 查询数据，根据该数据判断做出一些操作；事务 B 修改了相同数据；A 提交时作为判断依据的数据发生变化导致的不一致。使用 2PL 实现可串行化。

9，主从同步了解吗？

主库开启 binlog，授权一个账号给从库，从库访问主库的 binlog 记录到自己的 relay log，再从 relay log 解析 sql 语句。

10，redis 用过没？常用的数据类型有哪些？zset 是什么样子的。

同一面
zset 结构： key score member

11，zrange by score 的时间复杂度是多少？

O(lgN)
扩展：zset 上的插入查询都是 O(lgN)；set 上的插入查询都是 O(N)

12，redis 为什么是一个高性能的 key value 数据库。

数据在内存中，而不是硬盘，减少了 IO 时间
数据是内存的对象结构，而不是磁盘的文件结构，减少了 encode decode 时间
单线程，避免上下文切换。采用 epoll 的 IO 多路复用

13，epoll 和 select 的一个区别。

select 持有的 fd 有限，poll epoll 无上限
select poll 轮询，epoll 基于内核提供反射机制
select poll 都是水平触发；epoll 可选边缘触发，默认水平触发

14，水平触发 和 边缘触发 的区别是什么？

水平触发 LT：只要没读完，一直触发
边缘触发 ET：只触发一次，直到下次可读

15，redis 的集群了解吗？

集群有 2^14 = 16384 个哈希槽，每个 key 用 crc16 校验后对 16384 取模放到槽中
槽分布到节点中
节点和副本间采用异步的主从复制

16，单实例的 redis 能扛多少 qps？单实例的 mysql 呢？

需要实际测量，取决于库中的数据量、请求大小、硬件配置。
通常认为单机 redis w - 10w，mysql k - w。

17，公司项目中使用的 mysql 最高的qps是多少？

略

18，进程和线程的区别？

进程是应用程序在 cpu 上运行的一个抽象。是操作系统分配资源的最小单位。
线程是 cpu 调度的最小单位。在进程内线程可以共享变量，也可以有自己的局部变量。

19，协程了解过吗？具体实现的原理呢？

同一面

20，堆和栈的区别，操作系统和数据结构都分别说一下？

OS：
堆是应用程序管理的内存，用 new、malloc 分配，用 free 释放
栈是编译器管理的内存，自动分配，自动回收。
数据结构：
堆：数组实现的二叉树。最大堆：根节点最大，子节点总小于父节点；最小堆：反之亦然。
栈：先进后出

21，进程的内存布局了解吗？

见图

算法题，随机链表的拷贝。
