"""
缓存雪崩是什么
答：缓存雪崩是指缓存集中在某一时间失效，导致大量请求直接打到数据库上，造成数据库压力过大甚至宕机。
解决缓存雪崩方案：
答：1.设置不同的过期时间，比如在原来的基础上增加随机值，这样就不会集中在某一时间失效。
2.使用互斥锁，当一个线程访问数据库时，其他线程需要等待，直到第一个线程访问数据库结束，其他线程才能访问数据库。
3.使用热点数据永不过期。

缓存穿透是什么
答：缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时才会去数据库查询，所以这样的查询会直接打到数据库上，造成数据库压力过大甚至宕机。
解决缓存穿透方案：
答：1.使用布隆过滤器，当一个数据不存在时，将这个数据的key存入布隆过滤器中，当有请求查询这个数据时，先去布隆过滤器中查询，如果存在则直接返回，不存在再去数据库查询。
2.使用互斥锁，当一个线程访问数据库时，其他线程需要等待，直到第一个线程访问数据库结束，其他线程才能访问数据库。


缓存击穿是什么
答：缓存击穿是指缓存中某个数据过期，此时有大量请求查询这个数据，由于缓存是不命中时才会去数据库查询，所以这样的查询会直接打到数据库上，造成数据库压力过大甚至宕机。
解决缓存击穿方案：
答：1.使用互斥锁，当一个线程访问数据库时，其他线程需要等待，直到第一个线程访问数据库结束，其他线程才能访问数据库。
2.使用热点数据永不过期。

并发是什么
答：并发是指多个线程同时执行。

线程安全是什么
答：线程安全是指多个线程同时访问一个资源时，不会出现数据不一致的情况。

行锁是什么
答：行锁是指当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新。

表锁是什么
答：表锁是指当一个事务在读取某个表的数据时，其他事务不能在这个表上进行更新。

数据库的事务是什么
答：数据库的事务是指一组原子性的SQL语句，要么全部执行，要么全部不执行。

互斥锁是什么
答：互斥锁是指当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新。


幻读是什么
答：幻读是指在一个事务中读取了某个范围的数据，然后另一个事务在这个范围内插入了数据，这时第一个事务再次读取这个范围的数据，发现多了一些数据，这就是幻读。
解决幻读方案：
答：1.使用行锁，当一个事务在读取某个范围的数据时，其他事务不能在这个范围内插入数据。
2.使用乐观锁，当一个事务在读取某个范围的数据时，其他事务不能在这个范围内插入数据，但是可以在这个范围内更新数据，当第一个事务再次读取这个范围的数据时，发现多了一些数据，这时第一个事务可以回滚，重新读取数据。
3.使用悲观锁，当一个事务在读取某个范围的数据时，其他事务不能在这个范围内插入数据，也不能在这个范围内更新数据，当第一个事务再次读取这个范围的数据时，发现多了一些数据，这时第一个事务可以回滚，重新读取数据。
4.使用MVCC，当一个事务在读取某个范围的数据时，其他事务不能在这个范围内插入数据，也不能在这个范围内更新数据，当第一个事务再次读取这个范围的数据时，发现多了一些数据，这时第一个事务可以回滚，重新读取数据。

不可重复读是什么
答：不可重复读是指在一个事务中读取了某个数据，然后另一个事务在这个数据上进行了更新，这时第一个事务再次读取这个数据，发现数据已经被更新了，这就是不可重复读。
解决不可重复读方案：
答：1.使用行锁，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新。
2.使用乐观锁，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新，但是可以在这个数据上进行插入，当第一个事务再次读取这个数据时，发现数据已经被更新了，这时第一个事务可以回滚，重新读取数据。
3.使用悲观锁，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新，也不能在这个数据上进行插入，当第一个事务再次读取这个数据时，发现数据已经被更新了，这时第一个事务可以回滚，重新读取数据。
4.使用MVCC，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新，也不能在这个数据上进行插入，当第一个事务再次读取这个数据时，发现数据已经被更新了，这时第一个事务可以回滚，重新读取数据。

脏读是什么
答：脏读是指在一个事务中读取了某个数据，然后另一个事务在这个数据上进行了更新，这时第一个事务再次读取这个数据，发现数据已经被更新了，这就是脏读。
解决脏读方案：
答：1.使用行锁，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新。
2.使用乐观锁，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新，但是可以在这个数据上进行插入，当第一个事务再次读取这个数据时，发现数据已经被更新了，这时第一个事务可以回滚，重新读取数据。
3.使用悲观锁，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新，也不能在这个数据上进行插入，当第一个事务再次读取这个数据时，发现数据已经被更新了，这时第一个事务可以回滚，重新读取数据。
4.使用MVCC，当一个事务在读取某个数据时，其他事务不能在这个数据上进行更新，也不能在这个数据上进行插入，当第一个事务再次读取这个数据时，发现数据已经被更新了，这时第一个事务可以回滚，重新读取数据。

数据库事务的隔离级别
答：数据库事务的隔离级别有四种，分别是：读未提交、读已提交、可重复读、串行化。
1.读未提交：允许脏读、不可重复读、幻读。
2.读已提交：不允许脏读、允许不可重复读、允许幻读。
3.可重复读：不允许脏读、不可重复读、允许幻读。
4.串行化：不允许脏读、不可重复读、不允许幻读。


MVCC是什么
答：MVCC是多版本并发控制，它是一种乐观锁的实现方式，它的思想是：在读取数据时，不加锁，而是在事务提交时，判断数据是否被其他事务修改过，如果被修改过，则回滚，否则提交。

数据库事务的四大特性
答：数据库事务的四大特性有四种，分别是：原子性、一致性、隔离性、持久性。


布隆过滤器是什么
答：布隆过滤器是一种空间效率很高的随机数据结构，它可以用来告诉你，一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。

乐观锁和悲观锁的区别
答：乐观锁和悲观锁都是为了解决并发问题而产生的，乐观锁认为并发问题不会发生，悲观锁认为并发问题一定会发生。
1.乐观锁认为并发问题不会发生，所以在读取数据时不会加锁，只有在更新数据时才会判断在此期间是否有其他事务更新了这个数据，如果有则放弃本次更新，如果没有则更新数据。
2.悲观锁认为并发问题一定会发生，所以在读取数据时就会加锁，其他事务想要读取这个数据时就会被阻塞，直到这个事务提交或回滚。

数据库的索引有哪些
答：数据库的索引有三种，分别是：B+树索引、哈希索引、全文索引。

什么是并发
答：并发是指两个或两个以上的事件在同一时间段内发生。

什么是并行
答：并行是指两个或两个以上的事件在同一时刻发生。

什么是多线程
答：多线程是指在一个进程中，多个线程共享进程的资源。

什么是多进程
答：多进程是指每个进程都有自己独立的内存空间。

多线程怎么共享进程的资源
答：多线程怎么共享进程的资源，主要是通过线程的上下文切换来实现的。

tcp 7层模型
答：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

敏捷开发
答：敏捷开发是一种软件开发的方法论，它主要是通过迭代的方式来开发软件，每次迭代都会有一个可交付的软件，这样可以让客户更早的看到软件的成果，从而提高客户的满意度。

cookie和session的区别


答：cookie和session都是为了解决http无状态的问题而产生的，cookie是保存在客户端的，session是保存在服务端的。


多线程和多进程的区别
答：多线程和多进程都是为了解决并发问题而产生的，多线程是在一个进程中，多个线程共享进程的资源，多进程是每个进程都有自己独立的内存空间。

什么是线程安全
答：线程安全是指在并发环境下，多个线程访问同一个资源时，不会出现数据不一致的情况。

什么是协程
答：协程是指在一个线程中，多个协程共享线程的资源。

协程和多线程的区别
答：协程和多线程都是为了解决并发问题而产生的，协程是在一个线程中，多个协程共享线程的资源，多线程是在一个进程中，多个线程共享进程的资源。

协程的好处
答：协程的好处有两个，分别是：1.协程的切换比线程的切换要快，因为协程的切换不需要保存线程上下文，只需要保存协程上下文即可。
2.协程的内存占用比线程的内存占用要少，因为协程的内存占用只需要保存协程上下文即可，而线程的内存占用需要保存线程上下文、线程栈、寄存器等。

什么是面向对象
答：面向对象是指将对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。

什么是面向过程
答：面向过程是指将过程作为程序的基本单元，一个过程就是一系列的功能步骤的集合。

面向对象和面向过程的区别
答：面向对象和面向过程都是为了解决软件开发的复杂性而产生的，面向对象是将对象作为程序的基本单元，一个对象包含了数据和操作数据的函数，面向过程是将过程作为程序的基本单元，一个过程就是一系列的功能步骤的集合。

什么是面向切面
答：面向切面是指将一些与业务无关的功能抽离出来，单独处理，比如日志、安全、事务等。

什么是AOP
答：AOP是指面向切面编程，是一种编程范式，它将程序的业务逻辑和系统服务分离开来，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。

什么是IOC
答：IOC是指控制反转，是一种设计思想，它将创建对象的控制权交给了框架，而不是由程序员来控制。

什么是依赖注入
答：依赖注入是指将一个类的实例对象作为另一个类的成员变量，通过构造函数、函数参数、函数返回值等方式传递给另一个类。

什么是单例模式
答：单例模式是指一个类只有一个实例对象，它提供了一个全局访问点，可以通过这个全局访问点来访问这个唯一的实例对象。

什么是MVC
答：MVC是指模型-视图-控制器，它将一个软件系统分为三个基本部分：模型（Model）、视图（View）、控制器（Controller）。

什么是MVP
答：MVP是指模型-视图-表示器，它将一个软件系统分为三个基本部分：模型（Model）、视图（View）、表示器（Presenter）。

什么是MVVM
答：MVVM是指模型-视图-视图模型，它将一个软件系统分为三个基本部分：模型（Model）、视图（View）、视图模型（ViewModel）。

什么是设计模式
答：设计模式是指在软件开发过程中，针对特定问题的简洁而优雅的解决方案。

什么是观察者模式
答：观察者模式是指定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

什么是装饰者模式
答：装饰者模式是指动态地给一个对象添加一些额外的职责，就增加功能来说，装饰者模式比生成子类实现更为灵活。

什么是策略模式
答：策略模式是指定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

Python 的优点
答：Python 的优点有三个，分别是：1.简单易学，Python 语法简单，学习曲线低，上手快。
2.开源免费，Python 是一门开源的编程语言，它的源代码是免费的，可以自由使用。
3.丰富的第三方库，Python 有丰富的第三方库，可以满足大部分的开发需求。

Python 的缺点
答：Python 的缺点有三个，分别是：1.运行速度慢，Python 是一门解释型语言，它的运行速度比不上 C 语言等编译型语言。
2.代码不能加密，Python 是一门开源的编程语言，它的源代码是免费的，可以自由使用，但是它的源代码不能加密。
3.代码可读性差，Python 代码的可读性差，不利于维护。

Python 的应用场景
答：Python 的应用场景有三个，分别是：1.数据分析，Python 有丰富的第三方库，可以满足大部分的数据分析需求。
2.网络爬虫，Python 有丰富的第三方库，可以满足大部分的网络爬虫需求。
3.自动化运维，Python 有丰富的第三方库，可以满足大部分的自动化运维需求。

flask 和 Django 的区别
答：flask 和 Django 都是 Python 的 web 框架，它们的区别有三个，分别是：1.开发难度，Django 的开发难度比 flask 高。
2.性能，flask 的性能比 Django 高。
3.灵活性，flask 的灵活性比 Django 高。

django 的优点
答：django 的优点有三个，分别是：1.开发效率高，django 的开发效率高，开发周期短。
2.代码可维护性强，django 的代码可维护性强，便于后期维护。
3.社区活跃，django 的社区活跃，有大量的第三方库。

flask 的优点
答：flask 的优点有三个，分别是：1.开发效率高，flask 的开发效率高，开发周期短。
2.代码可维护性强，flask 的代码可维护性强，便于后期维护。
3.社区活跃，flask 的社区活跃，有大量的第三方库。


元组的优点
答：元组的优点有三个，分别是：1.元组是不可变的，元组的元素不能修改，因此元组是安全的。
2.元组的访问速度比列表快，元组的访问速度比列表快，因此元组是高效的。
3.元组可以作为字典的键，元组可以作为字典的键，因此元组是可哈希的。



什么是线程池
答：线程池是指在一个进程中，多个线程共享进程的资源。

什么是线程上下文切换
答：线程上下文切换是指在一个线程中，多个协程共享线程的资源。



什么是死锁
答：死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那他们都将无法推进下去。

死锁的四个必要条件
答：死锁的四个必要条件有四个，分别是：互斥条件、请求与保持条件、不剥夺条件、环路等待条件。

什么是锁
答：锁是指在并发环境下，为了保证数据的一致性，对数据进行加锁，使得在同一时刻只能有一个线程对数据进行操作。

什么是锁的粒度
答：锁的粒度是指锁的范围，锁的范围越大，锁的粒度越大，锁的范围越小，锁的粒度越小。


"""


def test():
    for i in range(10):
        print(i)
        # 执⾏行行到这⼀一⾏行行挂起
        yield


def main():
    # 生成⼀一个协程
    c = test()
    # next 就是执⾏行行协程
    next(c)
    next(c)
    next(c)


if __name__ == '__main__':
    main()
