"""


1，GIL 中文名是全局解释器锁（Global Interpreter Lock）。在 CPython 中是一把全局互斥锁（mutex）
用来保证在多线程的情况下，同一时刻只有一个线程在执行字节码。这样就保证了线程安全。CPython 是 Python 解释器的一种实现


2，为什么有 GIL
    GIL 于 1992 年被引入。在 Python 多线程的环境下，因为线程抢占式执行的机制导致想要实现某些功能会十分困难。

    例如，对于垃圾回收很重要的引用计数，当两个线程同时递增同一对象的引用计数时，引用计数最终可能只增加一次而不是两次。
    加入 GIL 后，能保证在同一时刻只有一个线程能获取到对象的读写权限，可以说非常简单粗暴。

    再比如 CPython 当中存在很多全局变量，要保证多线程对其修改正确，需要花费更多的精力，比如对锁的粒度进一步缩小，可是这样做，
    编码太复杂，而且容易造成死锁，维护起来也不方便。

    当然，如果有足够的人力和财力，Python 改头换面也不是没可能的


3，多线程如何实现切换
    需要了解到，Python 的运行机制是先将 py 文件中的内容转换成字节码，存储在 .pyc 文件中，然后再由解释器去执行字节码，
    本质上就是有一个 C 进程一直在读取字节码运行。而每一行字节码的执行类比于汇编中的指令执行。

    Python 线程一般会在遇到 IO 或者每执行满 100 行（每个版本可能数字不一样）字节码的时候（3.x 版本的时候引入了计时，比如每运行 5ms）,
    主动释放 GIL，这个时候其他等待锁的线程就有机会执行了。不过要注意的是，Python 线程最终还是要听操作系统调度，具体哪个线程能够运行，
    则是由优先级决定了。


4，在 Python 环境下什么操作线程安全什么操作线程不安全？为什么？
    在 Python 环境下，线程安全的操作是指在多线程环境下，不会出现数据不一致的情况。
    例如，对于一个列表，如果在多线程环境下，对列表进行 append 操作，那么就是线程不安全的。
    因为在多线程环境下，可能会出现两个线程同时对列表进行 append 操作，这样就会导致数据不一致。
    但是，如果对列表进行读取操作，那么就是线程安全的，因为在多线程环境下，对列表进行读取操作不会影响到其他线程。


5，GIL 会影响到什么？
    1，无法有效利用多核的优势，对于一个 Python 进程来说，永远都只有一个线程在一个核上运行，即使是多核 CPU。
    2，对于 CPU 密集型的任务场景，多进程会更慢，因为释放 GIL 会更频繁，系统调度更多，耗费资源加大


6.如何解决 GIL 的问题？
    1，使用多进程，每个进程有自己的 GIL，进程之间相互独立，不会互相影响。
    2，使用 C 扩展，C 扩展可以直接调用 C 语言的库，不受 GIL 的限制。
    3，使用 Cython，Cython 是 Python 的一个扩展，可以将 Python 代码编译成 C 代码，然后再编译成二进制文件，
    这样就可以直接调用 C 语言的库，不受 GIL 的限制。
    4，使用多线程，但是不要在多线程中执行 CPU 密集型的任务，比如计算密集型的任务，因为这样会导致 GIL 的释放频繁，
    从而导致系统调度更多，耗费资源加大。
    5，使用协程，协程是一种比线程更加轻量级的存在，协程的切换不需要系统调度，只需要切换到另一个协程，
    不需要释放 GIL，因此协程的切换比线程的切换更加高效。
    6，使用 asyncio，asyncio 是 Python 3.4 引入的标准库，可以用来编写异步 IO 的程序。
    7，使用多进程 + 协程，这是目前最好的解决方案，因为多进程可以充分利用多核 CPU 的优势，
    而协程又可以避免 GIL 的影响，因此可以充分发挥多核 CPU 的优势，同时又不会受到 GIL 的影响。


"""